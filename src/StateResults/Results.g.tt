<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Linq" #>
/*
    This file was generated automatically, do not make changes to it manually!
*/
#nullable enable

using OneOf;

namespace Application.Models.StateResults;

<#
    // Control the maximum number of types of errors
    const int maxErrorTypes = 6;

    for (var i = 2; i <= maxErrorTypes; i++)
    {
        var errorTypesArray = Enumerable.Range(0, i).Select(n => $"TE{n}").ToArray();
        var errorTypesText = string.Join(", ", errorTypesArray);
        var errorUnionText = $"OneOf<{errorTypesText}>";
#>
/// <summary>
///     Aggregates the result of some operation into itself. The result may be successful or not.
/// </summary>
/// <remarks>There can only be one state at a time.</remarks>
/// <typeparam name="TSuccess">Type of successful result.</typeparam>
<#
        // Set up a comment for each specific error type
        foreach (var specificErrorType in errorTypesArray)
        {
#>
/// <typeparam name="<#= specificErrorType #>">Type of possible unsuccessful result.</typeparam>
<#
        }
#>
[PublicAPI]
[DebuggerStepThrough]
[ExcludeFromCodeCoverage]
public readonly record struct Results<TSuccess, <#= errorTypesText #>> : IHasSuccessResult, IHasErrorResult
{
    // Store an index to track the state of this object
    // 'short' to align the size of the structure
    private readonly short _index = 0;

    private readonly TSuccess? _successValue;
    private readonly <#= errorUnionText #>? _errorUnion;


    /// <summary>
    ///     Initializes the result object with a successful state.
    /// </summary>
    /// <param name="value">Arbitrary result object.</param>
    /// <exception cref="ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
    public Results(TSuccess value)
    {
        ThrowIfNull(value);

        _successValue = value;
        _errorUnion = default;
    }

    /// <summary>
    ///     Initializes the result object with a state indicating that the result is unsuccessful.
    /// </summary>
    /// <param name="value">Arbitrary error result object.</param>
    /// <exception cref="ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
    public Results(<#= errorUnionText #> value)
    {
        ThrowIfNull(value);

        _index = 1;
        _successValue = default;
        _errorUnion = value;
    }


    /// <inheritdoc />
    public bool IsSuccess => _index == 0;

    /// <inheritdoc />
    public bool IsError => !IsSuccess;


    /// <exception cref="ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
    [Pure]
    public static implicit operator Results<TSuccess, <#= errorTypesText #>>(TSuccess value)
    {
        ThrowIfNull(value);

        return new Results<TSuccess, <#= errorTypesText #>>(value);
    }


<#
        foreach (var specificErrorType in errorTypesArray)
        {
#>
    /// <exception cref="ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
    [Pure]
    public static implicit operator Results<TSuccess, <#= errorTypesText #>>(<#= specificErrorType #> value)
    {
        ThrowIfNull(value);

        return new Results<TSuccess, <#= errorTypesText #>>(value);
    }


<#
        }
#>
    /// <exception cref="ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
    [Pure]
    public static explicit operator TSuccess?(Results<TSuccess, <#= errorTypesText #>> value) => value._successValue;


    /// <exception cref="ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
    [Pure]
    public static explicit operator <#= errorUnionText #>?(Results<TSuccess, <#= errorTypesText #>> value) => value._errorUnion;


<#
        for (var errorTypeIndex = 0; errorTypeIndex < errorTypesArray.Length; errorTypeIndex++)
        {
#>
    /// <exception cref="ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
    [Pure]
    public static explicit operator <#= errorTypesArray[errorTypeIndex] #>?(Results<TSuccess, <#= errorTypesText #>> value) =>
        value._errorUnion.HasValue
            ? value._errorUnion.Value.AsT<#= errorTypeIndex #>
            : default;


<#
        }
#>
    /// <summary>
    ///     Executes one of the provided delegates, depending on the current result.
    /// </summary>
    /// <param name="success">Function that will be executed in case of an unsuccessful state.</param>
    /// <param name="error">Function that will be executed in case of an unsuccessful state.</param>
    /// <typeparam name="TResult">Type of returning result.</typeparam>
    /// <returns>The result of one of the delegates.</returns>
    /// <exception cref="InvalidOperationException">Any of the delegates is <c>null</c>.</exception>
    [Pure]
    public TResult Match<TResult>(Func<TSuccess, TResult> success, Func<<#= errorUnionText #>, TResult> error)
    {
        ThrowIfNull(success);
        ThrowIfNull(error);

        return _index switch
        {
            0 when _successValue is not null => success(_successValue),
            1 when _errorUnion is not null   => error(_errorUnion.Value),
            var _                            => throw new InvalidOperationException()
        };
    }


    /// <summary>
    ///     Executes one of the provided delegates, depending on the current result.
    /// </summary>
    /// <remarks>Asynchronous version.</remarks>
    /// <param name="success">Function that will be executed in case of an unsuccessful state.</param>
    /// <param name="error">Function that will be executed in case of an unsuccessful state.</param>
    /// <typeparam name="TResult">Type of returning result.</typeparam>
    /// <returns>The result of one of the delegates.</returns>
    /// <exception cref="InvalidOperationException">Any of the delegates is <c>null</c>.</exception>
    [Pure]
    public Task<TResult> MatchAsync<TResult>(Func<TSuccess, Task<TResult>> success, Func<<#= errorUnionText #>, Task<TResult>> error)
    {
        ThrowIfNull(success);
        ThrowIfNull(error);

        return _index switch
        {
            0 when _successValue is not null => success(_successValue),
            1 when _errorUnion is not null   => error(_errorUnion.Value),
            var _                            => throw new InvalidOperationException()
        };
    }


    /// <summary>
    ///     Executes one of the provided delegates, depending on the current result.
    /// </summary>
    /// <param name="success">Action that will be executed in case of an unsuccessful state.</param>
    /// <param name="error">Action that will be executed in case of an unsuccessful state.</param>
    /// <exception cref="InvalidOperationException">Any of the delegates is <c>null</c>.</exception>
    public void Switch(Action<TSuccess> success, Action<<#= errorUnionText #>> error)
    {
        ThrowIfNull(success);
        ThrowIfNull(error);

        switch (_index)
        {
            case 0 when _successValue is not null:
            {
                success(_successValue);

                break;
            }
            case 1 when _errorUnion is not null:
            {
                error(_errorUnion.Value);

                break;
            }
            default : throw new InvalidOperationException();
        }
    }


    /// <summary>
    ///     Executes one of the provided delegates, depending on the current result.
    /// </summary>
    /// <remarks>Asynchronous version.</remarks>
    /// <param name="success">Action that will be executed in case of an unsuccessful state.</param>
    /// <param name="error">Action that will be executed in case of an unsuccessful state.</param>
    /// <exception cref="InvalidOperationException">Any of the delegates is <c>null</c>.</exception>
    public Task SwitchAsync(Func<TSuccess, Task> success, Func<<#= errorUnionText #>, Task> error)
    {
        ThrowIfNull(success);
        ThrowIfNull(error);

        return _index switch
        {
            0 when _successValue is not null => success(_successValue),
            1 when _errorUnion is not null   => error(_errorUnion.Value),
            var _                            => throw new InvalidOperationException()
        };
    }
}


<#
    }
#>